#!/usr/bin/env python3
from __future__ import print_function
import numpy as np
import argparse
import ase.io
import ase
from ase.visualize import view
from os import system,popen,chdir
import os.path
from re import search
from sys import exit
from ase.build import *
import ase.build
from ase import Atoms
import fractions
import copy
import time
import ase.build.tools
import matplotlib.pyplot as plt
import ase.calculators.castep
from spglib import find_primitive,standardize_cell,get_spacegroup #niggli_reduce from ASE-tools conflicts with that from spglib.

from ase.constraints import FixAtoms
#from ase.spacegroup import crystal


try:
        from os import popen4 #as popen
except:
        from os import popen #as popen

#Surface creation and alignment tool by James P. Darby.
#from join8 import *
from int import *


def misfit(slab1,slab2,ptol=2,ifPlot=False): #Computes the misfit parameter between two slabs. (see Surf. Interface Anal. 2003, 35, 835-841. )
        #Assuimng that two slabs are well aligned, overlap area should be equalt to smaller one's surface area.  !!FIND A MORE ACCURATE WAY OF DETERMINING OVERLAPPING SURFACE.
        #align_slab_axes(slab1,slab2,ptol)
        A1=surf_area(slab1);A2=surf_area(slab2)
        if ifPlot: plot_slab_axes(slab1,slab2)
        return 1 - 2*min(A1,A2)/(A1+A2)

def surf_area(slab1):
        return np.linalg.norm(np.cross(slab1.cell[0],slab1.cell[1]))

def volume(cell):
        return np.abs(np.dot(cell[2], np.cross(cell[0], cell[1])))

def get_fu(atoms):
        aTypes=atoms.get_chemical_symbols()
        atoms={}
        #print aTypes
        for at in aTypes:
            #print ln
            #at=ln.split()[0]
            if at not in atoms:atoms[at]=1
            else: atoms[at]+=1
        

        keys=list(atoms.keys())
        keys.sort()
        content=""
        for key in keys:
                content+=key
                if atoms[key]!=1:content+=str(atoms[key])

        #Determine the formula unit.

        try:
                fu=1
                vals=list(atoms.values())
                for i in range(2,min(vals)+1):
                        fl=1
                        for j in vals:
                                if j%i!=0:fl=0
                        if fl:fu=i
        #print fu
        except: print("Error in fu determination, fu set to 1");   fu=1
    
        return fu


                

def find_prim(atoms,tol=1e-4):#using SPGlib find primitive cell of a given atoms object.
        scaled_positions= atoms.get_scaled_positions()#(wrap=True) 
        cell=(atoms.cell, scaled_positions, atoms.numbers)
        #print cell
        print("Space group of the given cell using tolerance=%f: %s"%(tol,get_spacegroup(cell,symprec=tol)))
        lattice, scaled_positions, numbers = find_primitive(cell, symprec=tol)
        #lattice, scaled_positions, numbers = standardize_cell(cell, to_primitive=True, no_idealize=False, symprec=tol)
        atoms2=Atoms(symbols=numbers,cell=lattice,scaled_positions=scaled_positions,pbc=True)
        return atoms2

def grep(key,fname,n=-1): 
    #Uses grep to get the nth line with the keyword from a given file. By default the last occurence is returned.
        try:
                return popen4('grep -m %d "%s" %s '%(n,key,fname),"r")[1].readlines()[-1][0:-1] #don't take \n at the end.  #Fastest one!!!
        except: 
                return popen('grep -m %d "%s" %s '%(n,key,fname),"r").read()[0:-1]
        else:
                return ""

def call_castep(atoms,calc=None, typ="sp",PP='',wDir='./CASTEP-tmp',name='try',param='opt.param',resDir="",dipolCorr=False,dipolDir='z',KPgrid="1 1 1",KPspacing="", ifPrint=False,ifDryRun=False,ENCUT=0,ifManualRun=True,FixCell=False,FixList=[]):
    #For applying constraints (FixList) atom numbering starts from 1.


    #exe="mpirun -n 4 castep";PP_path='/rscratch/bk393/pspots/CASTEP'
    exe="mpirun -n 20 castep";PP_path='/u/fs1/bk393/pspots/CASTEP'

    #system("export CASTEP_COMMAND='%s'"%exe)
    #system("export CASTEP_COMMAND='mpirun -n 4 castep'")
    system("export CASTEP_PP_PATH='%s'"%PP_path)

    if calc!=None:
            #This is good for assiging the settings from a previously created Calculator object (i.e. not to repeat all the settings the second time). None of the other options will be taken into account.
            atoms.set_calculator(calc)
            #manual CASTEP run icin ayri bir function yap ve burda ve asagida cagir.
            return atoms 

    calc = ase.calculators.castep.Castep()

    #Assign the environment variables.
    calc._castep_command=exe
    calc._castep_pp_path=PP_path
    
    # include interface settings in .param file
    calc._export_settings = True

    # reuse the same directory
    calc._directory = wDir
    calc._rename_existing_dir = False
    calc._label = name

    
    if param:
        #Read paramters from param file input.
        calc.merge_param(param)
    else:        
        # Use default param settings (depreceated)
        calc.param.xc_functional = 'PBE'
        calc.param.cut_off_energy = 100 #500
        calc.param.num_dump_cycles = 0
        calc.param.geom_method = "lbfgs"
        calc.param.geom_max_iter= 10
        calc.param.write_cell_structure=True
        calc.param.spin_polarised=False
        calc.param.opt_strategy="speed"
        calc.param.mix_history_length=20
        calc.param.max_scf_cycles=100
        calc.param.calculate_stress=True
        #calc.param.finite_basis_corr=0
    
    # Cell settings
    #
    calc.cell.symmetry_generate=True
    calc.cell.snap_to_symmetry=True
    if KPspacing:calc.cell.kpoints_mp_spacing = str(KPspacing) #default=0.05 2pi*eV/A
    else: calc.cell.kpoint_mp_grid = KPgrid #def='1 1 1'
    
    #calc.cell.fix_com = False
    if FixCell: calc.cell.fix_all_cell = True
    if len(FixList)!=0:
            #c = FixAtoms(indices=[atom.index for atom in atoms if atom.symbol == 'Cu'])
            #c = FixAtoms(indices=FixList)
            #atoms.set_constraint(c) #This only work if the CASTEP is called by ASE (not for manual runs).

            str1=[]
            i=1
            for at in FixList:
                    atom=atoms[at]
                    #for j in range(1,4):
                    str1.append("%d %s %d %.8f %.8f %.8f"%(i,atom.symbol,atom.index,1,0,0))
                    str1.append("%d %s %d %.8f %.8f %.8f"%(i+1,atom.symbol,atom.index,0,1,0))
                    str1.append("%d %s %d %.8f %.8f %.8f"%(i+2,atom.symbol,atom.index,0,0,1))
                    i+=3

            calc.cell.ionic_constraints=str1 #a list object needed as input.
            calc.cell.snap_to_symmetry=False
            calc.cell.symmetry_generate=False
            
     
    #This overwrites the task paramter from the param input.
    if typ.lower()=="sp":    calc.param.task = 'SinglePoint'
    elif typ.lower()=="geom":calc.Task = 'GeometryOptimization'
    
    if dipolCorr: #def: No dipole corrections. 
        if dipolCorr=="SC": calc.param.dipole_correction= "SELFCONSISTENT"
        elif dipolCorr=="static": calc.param.dipole_correction= "static"
        else: calc.param.dipole_correction= "None"
        calc.param.dipole_dir=dipolDir #options: x,y,z and a (only energy-corr)

        
    
    #calc.initialize()#Creates all needed input in the _directory. (Not needed for actual run.)
    atoms.set_calculator(calc)  #Set for the previously created interface

    if ENCUT!=0: calc.param.cut_off_energy=ENCUT
    
    if PP!="":#otherwise on-the-fly(OTF) is used as default
        fnc=str(calc.param.xc_functional).split("\n")[1].upper()
        #print fnc
        PP=PP.upper()
        #print PP.lower().find(str(calc.param.xc_functional).lower())
        if PP != "OTF" and  PP.find(fnc)== -1:
                print("There is a problem with the pseudopotential choice. \nSelected PP does not match with XC functional being used: ",PP,fnc)
                exit()
        elif PP=="OTF": None #default is OTF anyway.
        else: atoms.calc.set_pspot(PP)  #This automatically sets the pseudo-potential for all present species to <Species>_<library>.usp. Make sure that _castep_pp_path is set correctly in the shell.


    # Or Read all settings from previous calculation
    if resDir != "": #Does not read from checkpoint file for some reason, needs to be checked !!
        # Reset to CASTEP default
        #atoms.calc.param.task.clear()
        atoms = ase.io.castep.read_seed('%s/%s' % (wDir,name))
        calc.param.reuse=True
        calc.param._try_reuse=True
        calc._export_settings = True
        #print atoms.calc,"bora\n\n",calc
        
    if ifPrint:print (calc) #prints calculation summary.

    # necessary for tasks with changing positions
    # such as GeometryOptimization or MolecularDynamics (This option does not work as deisgnated !!! The atomic coords are not updated at the end of the geom. opt. unlike the energy.
    calc._set_atoms = True
    atoms.calc._set_atoms = True
    
    
    # Check for correct input
    if not ifDryRun:
            if ifManualRun: #If a manual run of the CASTEP is needed.
                    #str1="%s %s/%s"%(exe,wDir,name)
                    str1="%s %s"%(exe,name)
                    print("Running ",str1)
                    calc._copy_pspots=True
                    calc.initialize()

                    chdir(wDir)
                    
                    system(str1) #PSPOT missing in the folder
                    #x=parseCASTEP("%s/%s.geom"%(wDir,name),atoms=atoms)
                    task=str(atoms.calc.param.task).split()[-1]
                    print(task)
                    if task=='SinglePoint' : #use <seed>.castep file
                            x=parseCASTEP("%s.castep"%(name),atoms=atoms)
                    elif task=='GeometryOptimization': #use <seed>.geom file.
                            x=parseCASTEP("%s.geom"%(name),atoms=atoms)
                            if x[-2]==False: print("parseCASTEP: WARNING: Geometry optimization in %s.geom is not converged!"%name)
                    else:
                            print("parseCASTEP: ERROR: Calculation type is not supported.")
                            x=None
                    chdir("..")
                    return x
                    
            else: #CASTEP calculation is not done here. It will be called in the main script, when trying to reach the attributes, e.g. atoms.get_potential_energy().
                    return atoms
    else:
            if calc.dryrun_ok():

                    return atoms
            else:
                    print("CASTEP run: Found error in input")
                    print((calc._error))
                    return None
            
def parseCASTEP(fname,atoms=None):
        #Read the CASTEP output to retrieve final 0K energy, atomic coords (Cart. and fractional), and forces.
        bohr2ang=0.52917721
        Ha2eV=27.211386
        atP2GPa=0.29421912e5 #P in atomic units to GPa.
        E=0.0;H=0.0 #Total Energy and Enthalpy
        h=[] #unit cell vectors
        s=[] # stress tensor
        xyz=[] #Cartesian atomic coords.
        forces=[] #forces in au (i.e. Ha/bohrradius).
        ifConv=0 #if the geometry is converged.
        fract=[]

        print("Parsing ",fname)
        if fname.split(".")[-1]=="geom":
                try: tSteps=len(popen("grep '<-- c' %s"%fname).readlines())-1
                except:tSteps=0

                flag=0
                for ln in open(fname,'r'):#.readlines(): #readlines is outdated and slow.
                        ln=ln[0:-1]
                        if not flag and search("<-- c",ln):
                                if int(ln.split()[0])==tSteps:
                                        #print 'here'
                                        flag=1
                                        if search("T   T   T   T",ln): ifConv=1

                        elif flag:
                                if search("<-- E",ln):E=float(ln.split()[1])*Ha2eV; H=float(ln.split()[1])*Ha2eV
                                elif search("<-- h",ln): h.append([float(i)*bohr2ang for i in ln.split()[0:3]])
                                elif search("<-- S",ln): s.append([float(i)*atP2GPa for i in ln.split()[0:3]])
                                elif search("<-- R",ln): xyz.append([float(i)*bohr2ang for i in ln.split()[2:5]])
                                elif search("<-- F",ln): forces.append([float(i)*(Ha2eV/bohr2ang) for i in ln.split()[2:5]])
                                
                                
       
        elif fname.split(".")[-1]=="castep":
                tSteps=0;latFlag=0;forces=[];s=[];h=[];latFlag=0;fract=[]
                for ln in open(fname,'r'):#.readlines(): #readlines is outdated and slow.
                        ln=ln[0:-1]
                        #if ln=="":continue
                        if len(ln)<=2: continue
                        elif "Unit Cell" in ln: #for getting only the last one
                                tSteps+=1
                                forces=[];s=[];h=[];latFlag=0;fract=[]
                        elif search("Final free energy \(E-TS\)    =",ln):H=float(ln.split("=")[1].split()[0])
                        elif search("Final energy, E",ln): E=float(ln.split("=")[1].split()[0])
                        elif search("\*  x ",ln) or search("\*  y ",ln) or search("\*  z ",ln): s.append([float(i) for i in ln.split()[2:5]]) #Stress tensor already in GPa.
                        elif len(ln)>2 and ln[1]=="\*" and len(ln.split())==7:
                                forces.append([float(i) for i in ln.split()[2:5]]) #already in eV/A
                        elif "            x" in ln and len(ln.split())==7:
                                fract.append([float(i) for i in ln.split()[3:6]])
                        elif "Real Lattice" in ln: latFlag=1;continue
                        elif "Lattice parameters" in ln: latFlag=0
                        elif  "Geometry optimization completed successfully." in ln: ifConv=1

                        if latFlag:  
                                if ln=="":latFlag=0;continue
                                h.append([float(i) for i in ln.split()[0:3]])
                                

                #Assuming it is a SP calculation (see call_CASTEP() function), so initial positions are not changed.
                
                if len(h)==0: print("Hey !!"); h=atoms.get_cell()#.tolist()  #if no Lattice infoin castep file (not likely).
                
                #xyz=atoms.get_positions()#.tolist()
                
                
        if atoms != None:
                print h
                atoms.set_cell(np.array(h))
                
                if len(xyz)!=0:atoms.set_positions(np.array(xyz))
                elif len(fract)!=0:atoms.set_scaled_positions(np.array(fract))

                #atoms.set_positions(np.array(xyz))
                
                return E, H, s, forces, ifConv, atoms
        else:
                #Energy, Enthalpy, stress tensor, Cart coords, fractional coords, atoms object.
                return E, H, s, h,  forces, xyz, fract, ifConv, atoms
        
def conv_layers(atoms,ifPlot=False,ifPrim=False):#layer convergence test (Input atoms with a calc object). 
        #print "Convergence of E/atom vs. #layers"
        Etol=1e-2 #eV/atom
        Ftol=5e-2 #eV/Angstroem
        Estr=0.1 #GPa

        #Initial values
        E=[0]; F=[0]; S=[0]
        atoms_orig=atoms.copy()
        calc=atoms.get_calculator()
        
        #find the primitive cells to reduce comp. efforts.
        if ifPrim: atoms=find_prim(atoms);atoms.set_calculator(calc)
        
        atoms.center(vacuum=4.0, axis=2)
        nAt=atoms.get_number_of_atoms()
        E.append(atoms.get_potential_energy()/nAt)
        i=1;layers=[1]
        while abs(E[i]-E[i-1]) > Etol:
                layers.append(1+1*i)
                atoms=atoms_orig.copy()
                atoms=atoms.repeat((1,1,layers[-1]))
                atoms.center(vacuum=4.0, axis=2)
                atoms.set_calculator(calc)
                #view(atoms)
                nAt=atoms.get_number_of_atoms()
                E.append(atoms.get_potential_energy()/nAt)
                print("Iter. #%d, #layers: %d, #atoms: %d "%(i,layers[-1],nAt))
                print("deltaE: %.3e eV/atom; target: %.3e eV."%(abs(E[i]-E[i-1]),Etol))
                i += 1
        print("conv_layers: E/atom converged to %.2f eV with %d layers."%(Etol,layers[-1]))
        if ifPlot: #Do plotting of E/atom vs. #layers
                plt.plot(layers,E[1:], 'ko-')
                plt.xlabel('Number of layers')
                plt.ylabel('Energy per atom (eV/atom)')
                #plt.savefig('layer-conv.png')
                plt.show()
                
        return layers[-1],E[-1]*nAt,atoms               

def get_interface_energy(slab1,slab2,Ebulk1,Ebulk2,dist=1.0,convLayers=False): #Input is slab1,slab2 as Atoms object with a calculator property assigned.
        if not slab2.has(calc):
                calc=slab1.get_calculator()
                slab2.set_calculator(calc)
        
        if convLayers: #A layer convergence test is done here!.
                print("Layer convergence test is switched on.")
                #slab1.set_calculator(calc)
                slab1=call_castep(slab1,typ="SP",dipolCorr='SC',name='slab1',ENCUT=ecut,KPgrid='1 1 1',PP=pp) #Use SP for efficiecy.
                calc=slab1.get_calculator()       
                print("Working on slab 1.")
                nl1,Eslab1,slab1=conv_layers(slab1)#,ifPrim=1)  #Vacuum layer is added automatically within the function.
                fu1=get_fu(slab1)
                
                #slab2=call_castep(slab2,typ="SP",dipolCorr='SC',name='slab2',ENCUT=ecut,KPgrid='1 1 1',PP=pp)
                
                slab2.set_calculator(calc)
                slab2.calc._label="slab2"    #change name for slab2
                print("Working on slab 2.")                
                nl2,Eslab2,slab2=conv_layers(slab2)#,ifPrim=1)

                fu2=get_fu(slab2)
                print(nl1,nl2,Eslab1,Eslab2,fu1,fu2)

        else:
                slab1_vac=slab1.copy();slab2_vac=slab2.copy();
                slab1_vac.center(vacuum=4.0, axis=2)
                slab2_vac.center(vacuum=4.0, axis=2)
                #atoms=call_castep(slab1_vac,typ="SP",dipolCorr='SC',name='slab1',ENCUT=ecut,KPgrid='1 1 1',PP=pp)
                atoms=slab1_vac
                atoms.set_calculator(calc)
                Eslab1=atoms.get_potential_energy()
                fu1=get_fu(atoms)
                
                #atoms=call_castep(slab2_vac,typ="SP",dipolCorr='SC',name='slab2',ENCUT=ecut,KPgrid='1 1 1',PP=pp)
                atoms=slab2_vac
                atoms.set_calculator(calc)
                atoms.calc._label="slab2"
                Eslab2=atoms.get_potential_energy()
                fu2=get_fu(atoms)

        #view(slab1.repeat((2,2,1)))
        #view(slab2.repeat((2,2,1)))
        ase.io.write("slab1.cell",slab1.repeat((1,1,1)),format='castep-cell')
        ase.io.write("slab2.cell",slab2.repeat((1,1,1)),format='castep-cell')
        #ase.io.write("slab11.cell",slab1a,format='castep-cell')

        Ws1=(Eslab1-fu1*Ebulk1)/2/surf_area(slab1)/0.01 #A2 to nm2
        Ws2=(Eslab2-fu2*Ebulk2)/2/surf_area(slab2)/0.01 #A2 to nm2
        
        print(('%s: %s eV' % ('Ebulk 1', Ebulk1)))
        print(('%s: %s eV' % ('Ebulk 2', Ebulk2)))
        print(('%s: %s eV' % ('Eslab 1', Eslab1)))
        print(('%s: %s eV' % ('Eslab 2', Eslab2)))
        print(('%s: %.2f eV/nm^2' % ('Wsurf 1', Ws1)))
        print(('%s: %.2f eV/nm^2' % ('Wsurf 2', Ws2)))

        #exit()
        
        #Interface before alignment.
        print("Creating the interface with given slabs.")
        int1=ase.build.stack(slab1, slab2, axis=2, maxstrain=None, distance=dist,cell=None,reorder=True)
        int1.center(vacuum=4.0,axis=2)
        view(int1)
        ase.io.write("interface1.cell",int1.repeat((1,1,1)),format='castep-cell')
        atoms=call_castep(slab1_vac,typ="SP",dipolCorr='SC',name='int1',ENCUT=500,KPgrid='1 1 1',PP=pp)
        #atoms=int1
        #atoms.set_calculator(calc)
        Eint=atoms.get_potential_energy()

        #Wad=(Ws1+Ws2-Eint)/surf_area(int1)/0.01 #A2 to nm2 #check the formula Ea isntead of Wsurf?? This is wrong
        #print('Wad before alingment: %.2f eV/nm^2'%Wad)

        Wad=(Eslab1+Eslab2-Eint)/surf_area(int1)/0.01 #A2 to nm2 #check the formula Ea isntead of Wsurf??
        
        print(('W_ad before alingment: %.2f eV/nm^2'%Wad))
        return Eslab1,Eslab2,Ws1,Ws2,int1#surf_area(int1)


def make_slab(atoms1,miller1,max_atoms_1,vac=0):#New, adapted from from int.py
        cell1 = Cell(atoms1)

        #get the new cell vectors needed to create the desired surface
        slab1 = Slab(miller1, cell1)
        slab1.set_Rmax(max_atoms_1)


        #find all vectors in slabs with length <= Rmax
        #returns shortest vector in each direction, none are parallel
        vecs1 = find_vecs(slab1,Rmax)

        #construct pairs
        pairs1 = build_pairs(vecs1,slab1)


        #TODO insert a symmetry reduction for pairs

        #filter pairs, all angles should be between 60 and 150 degrees
        #if a match could be made outside of this range then gauss reduction on the match
        #would bring theta into the desired range and with shorter lattice vectors
        pairs1 = angle_filter(pairs1)

        #if slab only find the best pair in pairs 1 and write out that slab, after repeating ofc
        #if args.slab_only:

        pair1 = best_pair(pairs1)			
        out_slab = make_cells(pair=pair1)


        #convert thicknesses to creps
        if args.creps_1 is not None:
                cr1 = args.creps_1
        else:
                c = np.linalg.norm(out_slab.cell[2])	
                cr1 = int(np.ceil(args.thickness/c))

        #repeat the slab, replace with function
        out_slab.crep(cr1)	
        if vac > 0.001:			
                out_slab.square()
                out_slab.add_vac(0.5* vac) 

        #write out the slab 
        at1 = ase.atoms.Atoms(symbols=out_slab.symbols, scaled_positions=out_slab.frac, cell=out_slab.cell)

        return at1

def slab_aligner(slab1,slab2,max_atoms_1,max_atoms_2,percentage_tolerance,thickness,creps_1=None,creps_2=None):
        cell1 = Cell(atoms1)
        cell2 = Cell(atoms2)


        #get the new cell vectors needed to create the desired surface
        slab1 = Slab(miller1, cell1)
        slab1.set_Rmax(args.max_atoms_1)
        slab2 = Slab(miller2,cell2)
        slab2.set_Rmax(args.max_atoms_2)
        #only need to check out as far as the shorter Rmax	
        Rmax = min(slab1.Rmax,slab2.Rmax)	


        #find all vectors in slabs with length <= Rmax
        #returns shortest vector in each direction, none are parallel
        vecs1 = find_vecs(slab1,Rmax)
        vecs2 = find_vecs(slab2,Rmax)	

        #construct pairs
        pairs1 = build_pairs(vecs1,slab1)
        pairs2 = build_pairs(vecs2,slab2)


        #TODO insert a symmetry reduction for pairs

        #filter pairs, all angles should be between 60 and 150 degrees
        #if a match could be made outside of this range then gauss reduction on the match
        #would bring theta into the desired range and with shorter lattice vectors
        pairs1 = angle_filter(pairs1)
        pairs2 = angle_filter(pairs2)
        matches = match_pairs(pairs1,pairs2,percentage_tolerance, Rmax)	



        #TODO symmetry reduce matches, do it here or might be easier/more efficient to do
        #it earlier, e.g. symmetry reduce the vectors before pairs are constructed
        #that won't get all symetry equivalents though... maybe it is best just to reduce
        #matches...??
        match = find_best_match(matches)

        #match = matches[0]
        print("there are ",len(matches), "matches")

        #pair 1 is bottom cell, pair 2 is top cell
        top_cell, bot_cell = make_cells(match=match)
        print("made cells")

        #convert thicknesses to creps
        if args.creps_1 is not None:
                cr1 = args.creps_1
        else:
                c = np.linalg.norm(top_cell.cell[2])	
                cr1 = int(np.ceil(args.thickness/c))


        if args.creps_2 is not None:
                cr2 = args.creps_2
        else:
                c = np.linalg.norm(bot_cell.cell[2])	
                cr2 = int(np.ceil(thickness/c))

        top_cell.crep(cr1)
        bot_cell.crep(cr2)

        print("c repeated cells")

        #square the slabs and then stack themn		
        bot_cell.square()
        top_cell.square()

        #write the top and bottom cell out as .cell files
        at1 = ase.atoms.Atoms(symbols=top_cell.symbols, positions=top_cell.positions,cell=top_cell.cell)
        at1.set_pbc([True,True, False])

        #ase.io.write("top.cell",at1,format="castep-cell")
        at2 = ase.atoms.Atoms(symbols=bot_cell.symbols, scaled_positions=bot_cell.frac,cell=bot_cell.cell)
        #ase.io.write("bot.cell",at2,format="castep-cell")
        at2.set_pbc([True, True, False])
        #symmetry = spglib.get_symmetry(at1)	


        #check number densities of the slabs
        n1 = compare_density(at1, atoms1)
        n2 = compare_density(at2, atoms2)

        return at1,at2

def shifter(top_cell,bot_cell,shift_grid,vac,args):
        #get the symmetry translation vectors for each slab
        tt1, tt2, tA = get_symmetry_translations(top_cell)
        bt1, bt2, bA = get_symmetry_translations(bot_cell)	
        #as shifts are relative, take the shifts with smaller area
        #BUT can always shift the top cell w.l.o.g
        if tA < bA:
                shifts = [tt1,tt2]
        else:
                shifts = [bt1,bt2]

        #	shift the final section into a function called stack_and_write
        #then create list of shifted cells to pass to stack_and_write 
        #so will end up with one call generating all the required shifts	
        n,m = shift_grid
        n = int(n);		m = int(m)
        for i in range(0,n):
                for j in range(0,m):
                        t1 = shifts[0]/n * i
                        t2 = shifts[1]/m * j


                        #apply the shifts and then create the interface
                        bot_cell0 = copy_cell(bot_cell)		
                        bot_cell0.shift(t1+t2)
                        interface = stack(top_cell, bot_cell0, vac=vac)		
                        write_cell_2_res(interface, args, i,j,n,m)

def cell2Atoms(top_cell):
        return Atoms(symbols=top_cell.symbols, positions=top_cell.positions,cell=top_cell.cell,pbc=[True, True,True])

def slab_aligner_old(slab1,slab2,L,Lmax,Lstep,ptol,thickness):
        #find and repeat slabs as specified,
        #One should use only 1 layer for a layer convergence test.
        choice = find_commensurate_supercell(slab1,slab2,Lmax,Lstep,ptol)
        crep = np.ceil(abs(thickness/np.dot(slab1.cell[2],(0,0,1))))
        slab1 = cut_cell(slab1,choice[2],choice[3],(0,0,crep))
        slab1 = square_slab(slab1)
        crep = np.ceil(abs(thickness/np.dot(slab2.cell[2],(0,0,1))))
        slab2 = cut_cell(slab2,choice[4],choice[5],(0,0,crep))
        slab2 = square_slab(slab2)

        #rotate slab2 so that it is alligned with slab1
        ase.build.rotate(slab2,slab1.cell[2],slab2.cell[2],slab2.cell[0],slab1.cell[0])

        #confirm that atom densities are the same as at the start
        atom_density_check(atoms1,slab1)
        atom_density_check(atoms2,slab2)
        
        return slab1,slab2


##################################################
#                  MAIN METHOD                   #
##################################################
               
if __name__== '__main__':
        #read in arguments
        parser = argparse.ArgumentParser()
        parser.add_argument("-i1", "--infile1", default="Li.cell")
        parser.add_argument("-o", "--outfile")
        parser.add_argument("-i2", "--infile2", default="Al.cell")
        parser.add_argument("-m1","--miller1", default=(1,0,0), nargs="+", type=int)
        parser.add_argument("-m2","--miller2", default=(1,0,0), nargs="+", type=int)
        #parser.add_argument("-msd","--max_slab_dimension",default=50)
        parser.add_argument("-th","--thickness",default=7,type=float)
        #parser.add_argument("-pt","--percentage_tolerance",default=4)
        parser.add_argument("-conv", "--convLayers",action="store_true",default=False,help="To run a convergence test for slab(s) generated.")

        parser.add_argument("-t","--type",choices=['s','i'],help="s: check different slabs of given bulk structure(s), i: create interface from the slabs with -m1 and -m2 Miller indices from input bulk structures.")


        parser.add_argument("-n1","--max_atoms_1",default=20,type=int,help="max atoms in slab 1")	
        parser.add_argument("-n2","--max_atoms_2",default=20,type=int,help="max atoms in slab 1")	
        parser.add_argument("--slab_only", action="store_true")
	#parser.add_argument("-t","--thickness",default=7,type=float)
        parser.add_argument("-cr1","--creps_1",default=None,type=int,help="overrides thickness")
        parser.add_argument("-cr2","--creps_2",default=None,type=int)
        parser.add_argument("-pt","--percentage_tolerance",default=5.0, type=float)
        parser.add_argument("-d","--distance",default=1, type=float)
        parser.add_argument("-v","--vac",default=0, type=float)
        parser.add_argument("-sg","--shift_grid",default=(1,1,), type=float, nargs="+", help = "2 integers to specify the size of the shift grid" 	)
        parser.add_argument("--res", action="store_true")

        args = parser.parse_args()

        infile1 = args.infile1
        miller1 = tuple(args.miller1)
        infile2= args.infile2
        miller2 = tuple(args.miller2)

        #2 is going on the bottom so m2 ->-m2 to get right orientation of the surface (in James' new version)
        miller2 = [-x for x in miller2]


        if args.outfile:
                outfile = args.outfile
        else:
                outfile ="interfaces.out"

        system("date >> %s"%outfile)
        outf=open(outfile,'a')
        

        """
        #tolerances
        Lmax = args.max_slab_dimension 	#max length of cell sides
        L = 5 # initial length
        Lstep = 5
        #T = 1.5	#thickness of slabs
        T=args.thickness
        ptol = args.percentage_tolerance	#percentage tolerances for angle and length matching
        """

        miller_list=[(1,1,1),(1,1,0),(1,0,0)]

        #Common DFT-related parameters.
        ecut=250 #cutoff energy in eV (convergence prob. with lower cutoffs).
        pp="00PBE" #pseudopt to use in CASTEP calcs.Def (pp=""): OTF
        dirr="./CASTEP-tmp"

        #read in atoms and construct slab, need to repeat atoms to make view work
        print("Reading data from %s and %s."%(infile1,infile2))
        if infile1.split(".")[1]=="cell":
                atoms1 = ase.io.read(infile1, format='castep-cell')
        elif infile1.split(".")[1]=="cif":
                atoms1 = ase.io.read(infile1, format='cif')
        if infile2.split(".")[1]=="cell":
                atoms2 = ase.io.read(infile2, format='castep-cell')
        elif infile2.split(".")[1]=="cif":
                atoms2 = ase.io.read(infile2, format='cif')            

        initT=time.time()

        print("Structure 1: %s with fu=%d"%(atoms1.get_chemical_formula(),get_fu(atoms1)))
        print("Structure 2: %s with fu=%d"%(atoms2.get_chemical_formula(),get_fu(atoms2)))

        if 0: atoms1=find_prim(atoms1); atoms2=find_prim(atoms2) #Whether to use primitive cells of input structures.

        #Delete calculation files from previous CASTEP run.
        #system("rm -f %s/*"%dirr)
        system("rm -f interface.cell  interface0a.cell  slab1.cell  slab1_aligned.cell  slab1_aligned_opted.cell  slab2.cell  slab2_aligned.cell  slab2_aligned_opted.cell")
        print()


        ########################
        # Do bulk calculations #
        ########################
        #Check if data from a previous run is available (not to repeat the same calcs for bulk).
        fn1="%s/bulk1.castep"%dirr; fn2="%s/bulk2.castep"%dirr
        if os.path.exists(fn1):
                print ("%s was located, reading data..."%fn1)
                x1=parseCASTEP(fn1,atoms1)

        else:  # whether to compute bulk energies/structures
                print("Computing bulk 1 energy.")
                x1=call_castep(atoms1,typ="geom",dipolCorr='None',name='bulk1',ENCUT=ecut,PP=pp,KPspacing=0.10) #normally use K-point spacing.

        if os.path.exists(fn2):
                print ("%s was located, reading data..."%fn2)
                x2=parseCASTEP(fn2,atoms2)

        else:  
                print("Computing bulk 2 energy.")
                x2=call_castep(atoms2,typ="geom",dipolCorr='None',name='bulk2',ENCUT=ecut,PP=pp,KPspacing=0.10) #normally use K-point spacing.


        atoms1=x1[-1]
        Ebulk1=x1[0]

        fu1=get_fu(atoms1)
        sa1=surf_area(atoms1)
        #Ebulk1 /= fu1 #Get the bulk energy per formula unit.
        Ebulk1 /= len(atoms1) #Get the bulk energy per atom.

        atoms2=x2[-1]
        Ebulk2=x2[0]

        fu2=get_fu(atoms2)
        #Ebulk2 /= fu2
        Ebulk2 /= len(atoms2) #Get the bulk energy per atom.
        sa2=surf_area(atoms2)

        del x1,x2

        if args.type=="s":
                #str1=""
                min_Ws=1e8; min_mil=();min_slab=None
                for mil in miller_list: #fix the old functions.
                        #slab1 = make_slab(mil,atoms1,repeat=(1,1,1),square=False)
                        #slab1.center(vacuum=4.0, axis=2)

                        slab1=make_slab(mil,atoms1,args.max_atoms_1,vac=4.0) #new version.

                        x=call_castep(slab1,typ="sp",dipolCorr='sc',name='slab1',ENCUT=ecut,KPgrid='4 4 1',PP=pp)
                        slab1=x[-1]
                        Eslab1=x[0]
                        Ws1=(Eslab1-len(slab1)*Ebulk1)/2/surf_area(slab1)/0.01 #A2 to nm2
                        str1='%s (%s_%d%d%d): %.2f eV/nm^2\n' % ('Wsurf 1', slab1.get_chemical_formula(),mil[0],mil[1],mil[2],Ws1)
                        if Ws1<min_Ws: min_Ws=Ws1; min_mil=mil;min_slab=slab1
                        outf.writelines(str1)
                        print (str1)

                if args.convLayers:#Run layer thickness
                        #slab1 = make_slab(min_mil,atoms1,repeat=(1,1,1),square=False)
                        slab1=min_slab
                        nl1,Eslab1,slab1=conv_layers(slab1)#,ifPrim=1)  #Vacuum layer is added automatically within the function.

                        #BURDA!!!
                exit()


        """
        #######################################################################
        #Create the intial slabs with given Miller indices (before alignment).#
        #######################################################################
        print("\nCreating the initial slabs.")
        print (miller1,miller2)
        slab1 = make_slab(miller1,atoms1,repeat=(1,1,1),square=False)
        slab2 = make_slab(miller2,atoms2,repeat=(1,1,1),square=False)



        if 0: #to calculate energies/structures of the initial slabs (before alignment).
                print("Pre-optimizing the initial slabs (before alignment).")
                if 1: #to add vacuum to the slabs (needed)
                        slab1.center(vacuum=4.0, axis=2)
                        slab2.center(vacuum=4.0, axis=2)

                x=call_castep(slab1,typ="geom",dipolCorr='sc',name='slab1',ENCUT=ecut,KPgrid='1 1 1',PP=pp)
                slab1=x[-1]
                Eslab1=x[0]

                x=call_castep(slab2,typ="geom",dipolCorr='sc',name='slab2',ENCUT=ecut,KPgrid='1 1 1',PP=pp)
                slab2=x[-1]
                Eslab2=x[0]
                #calc=at.get_calculator()



        #Not originally here. (Helps increase the overlap between surfaces. i.e. lower lattice misfit).
        niggli=0
        if niggli: niggli_reduce(slab1);niggli_reduce(slab2)

        if 0: slab1=find_prim(slab1);slab2=find_prim(slab2) #does not work.

        if 1: #to add vacuum to the slabs (for demonstration)
                slab1_vac=slab1
                slab2_vac=slab2
                slab1_vac.center(vacuum=4.0, axis=2)
                slab2_vac.center(vacuum=4.0, axis=2)

                ase.io.write("slab1.cell",slab1_vac.repeat((1,1,1)),format='castep-cell')
                ase.io.write("slab2.cell",slab2_vac.repeat((1,1,1)),format='castep-cell')
        else:
                ase.io.write("slab1.cell",slab1.repeat((1,1,1)),format='castep-cell')
                ase.io.write("slab2.cell",slab2.repeat((1,1,1)),format='castep-cell')



        #print("\nMisfit (mu) of slabs 1 and 2 (before alignment): %.2f%%"%(misfit(slab1,slab2)*100))#,ifPlot=1)
        #print
        #exit()

        """

        ######################
        # Alignment of Slabs #
        ######################
        print("\nAligning the two slabs...")
        #slab1,slab2=slab_aligner(slab1,slab2,L,Lmax,Lstep,ptol,T)
        slab1,slab2=slab_aligner(atoms1,atoms2,args.max_atoms_1,args.max_atoms_2,args.percentage_tolerance,args.thickness,args.creps_1,args.creps_2)
        print("\nMisfit (mu) of slabs 1 and 2 (after alignment): %.2f%%"%(misfit(slab1,slab2)*100))#,ifPlot=1)
        

        ase.io.write("slab1_aligned.cell",slab1,format='castep-cell')
        ase.io.write("slab2_aligned.cell",slab2,format='castep-cell')

        """
        if 1:
        #Interface before optimizing the individual slabs.
                interface=ase.build.stack(slab1, slab2, axis=2, maxstrain=None, distance=2.0,cell=None,reorder=True)  #using 0 distance btw slabs gives CASTEP error.
                interface.center(vacuum=4.0, axis=2) #Vacuum on both sides. For dipole corrections at least 8A vacuum is needed.
                #view(interface)

                ase.io.write("interface0a.cell",interface,format='castep-cell')
                #ase.io.write("interface0a.cif",interface,format='cif')
        """

        if 1: #to calculate energies/structures of the actual slabs (after alignment).
                print("\nOptimizing the slabs 1 and 2 (after alignment).")

                if 0: #to add vacuum to the slabs (needed) #already added by make_slab.
                        slab1.center(vacuum=args.vac, axis=2)
                        slab2.center(vacuum=args.vac, axis=2)

                x=call_castep(slab1,typ="geom",dipolCorr='sc',name='slab1-aligned',ENCUT=ecut,KPgrid='1 1 1',PP=pp,FixCell=True)#,FixList=[1,2])
                #x=call_castep(slab1,typ="sp",dipolCorr='sc',name='slab1-aligned',ENCUT=ecut,KPspacing=0.10,PP=pp)
                slab1=x[-1]
                Eslab1=x[0]

                x=call_castep(slab2,typ="geom",dipolCorr='sc',name='slab2-aligned',ENCUT=ecut,KPgrid='1 1 1',PP=pp,FixCell=True)
                #x=call_castep(slab2,typ="sp",dipolCorr='sc',name='slab2-aligned',ENCUT=ecut,KPspacing=0.10,PP=pp)
                slab2=x[-1]
                Eslab2=x[0]


                #Compute the surfafce energies.
                #Ws1=(Eslab1-fu1*Ebulk1)/2/surf_area(slab1)/0.01 #A2 to nm2
                #Ws2=(Eslab2-fu2*Ebulk2)/2/surf_area(slab2)/0.01 #A2 to nm2
                Ws1=(Eslab1-len(slab1)*Ebulk1)/2/surf_area(slab1)/0.01 #A2 to nm2
                Ws2=(Eslab2-len(slab2)*Ebulk2)/2/surf_area(slab2)/0.01 #A2 to nm2

                str1=''
                str1+='%s: %s eV\n' % ('Ebulk 1', Ebulk1)
                str1+='%s: %s eV\n' % ('Ebulk 2', Ebulk2)
                str1+='%s (%s_%d%d%d): %.2f eV/nm^2\n' % ('Wsurf 1', slab1.get_chemical_formula(),miller1[0],miller1[1],miller1[2],Ws1)
                str1+='%s (%s_%d%d%d): %.2f eV/nm^2\n' % ('Wsurf 2', slab2.get_chemical_formula(),miller2[0],miller2[1],miller2[2],Ws2)

                print(str1)
                outf.writelines(str1)

                #view(slab1.repeat((1,1,1)))
                ase.io.write("slab1_aligned_opted.cell",slab1,format='castep-cell')
                ase.io.write("slab2_aligned_opted.cell",slab2,format='castep-cell')

        #Create the interface.
        
        if 1: 
                interface=ase.build.stack(slab1, slab2, axis=2, maxstrain=None, distance=2.0,cell=None,reorder=True)  #using 0 distance btw slabs gives CASTEP error.
                #interface = wrap_coords(interface)
                #interface.wrap()
                interface.center(vacuum=args.vac, axis=2) #Vacuum on both sides. For dipole corrections at least 8A vacuum is needed.
        else:

                #top_cell = Cell(slab1)
                #bot_cell = Cell(slab2)

                interface=stack(top_cell,bot_cell,vac=args.vac)
                interface=cell2Atoms(interface)

        view(interface)

        ase.io.write("interface.cell",interface,format='castep-cell')
        #ase.io.write("interface.cif",interface,format='cif')



        #if niggli: niggli_reduce(interface)


        if 1:
                print("\nOptimizing the final interface geometry.")
                x=call_castep(interface,typ="opt",dipolCorr='SC',name='interface',ENCUT=ecut,KPgrid='1 1 1',PP=pp)
                interface=x[-1]
                Eint=x[0]


                Wad=(Eslab1+Eslab2-Eint)/surf_area(interface)/0.01 #A2 to nm2 #check the formula Ea isntead of Wsurf??
                str1='W_ad after alingment: %.2f eV/nm^2'%Wad
                print(str1)
                outf.writelines(str1)

                ase.io.write("interface_opted.cell",interface,format='castep-cell')
                ase.io.write("interface_opted.cif",interface,format='cif')
                      

        outf.close()

        print ("Elapsed time: %.2f sec."%( time.time()-initT))

        exit()


##################
# Excluded Parts #
##################

#Setting system variables inside the Python code deos not work. Has to be done in the shell.
#exe="mpirun -n 4 castep"; PP_path='/rscratch/bk393/pspots/CASTEP'
#system("export CASTEP_COMMAND='%s'"%exe)
#system("export CASTEP_COMMAND='mpirun -n 4 castep'")
#system("export CASTEP_PP_PATH='%s'"%PP_path)


#Randomise atomic positions (not needed).
#slab1.rattle(stdev=0.3) #def: 0.001
#slab2.rattle(stdev=0.3) #def: 0.001


        #atoms1.calc._set_atoms=True
#print atoms1.calc
#Ebulk1=atoms1.get_potential_energy() #returns 0K energy (E-0.5TS).

#print Ebulk1
#print atoms1.get_potential_energy(force_consistent=True) #returns free enrergy (E-TS) 
#print atoms1.get_total_energy()  #same as potential energy (E-0.5TS).
#print atoms1.get_positions()
#print atoms1.get_scaled_positions()
#This does the geoemtry optimization and gets the final energy however the atomic positions (Cart or fractional) are not updated (even using the ._set_atoms=True option !!! This alos applies to get_total_energy etc. CASTEP must be run by hand and the output must be parsed (use _prepare_input_only option for CASTEP input files)!!! No problem with SP as no update on atomic coords.


Li = bcc110("Li", (4, 4, 6)) #This one is the lowest surface.No of repetitions.
#Li = surface('Li', (1, 1, 0), 3)#,10) #You don't have to know about the type fcc,hcp, etc. 
Li.center(vacuum=10, axis=2) #Adds 10A vacuum in z-dir
Li.set_pbc(1)
view(Li)

exit()








#typ=sp or typ=geom
atoms=call_castep(interface,typ="sp",name='run1')
#atoms.calc._pedantic=True
print(('%s: %s ' % ('Ep without dipole corr', atoms.get_potential_energy())))
#atoms.calc.param.reuse = True  #needs check file to be present.
#atoms.calc._try_reuse=True #does not help.
#atoms=call_castep(interface,typ="SP",name='run1',resDir="./CASTEP-tmp")
#print('%s: %s ' % ('E', atoms.get_total_energy())) #CASTEP calc. is repeated every time !!

exit()
atoms=call_castep(interface,typ="SP",dipolCorr='SC',name='run2')
print(('%s: %s ' % ('Ep with dipole corr', atoms.get_potential_energy())))


#get_potential_energy()=get_total_energy() for castep.

#print('%s : %s ' % (atoms.calc._label, atoms.get_dipole_moment()))
#print('%s : %s ' % (atoms.calc._label, atoms.get_charges()))

"""get_potential_energy()
get_potential_energies()
get_forces()
get_stress()
get_stresses()
get_total_energy()
get_magnetic_moments()
get_magnetic_moment()
"""
exit()

#One should also check the strain when creating the interface.
interface = ase.build.stack(slab1, slab2, axis=2, maxstrain=2, distance=1.0,cell=None,reorder=True)
interface.wrap()
interface.center(vacuum=7.5, axis=2)

view(interface)



"""
                if 0: #use the same settings as for bulk 1. #does not work (check!!)
                        calc=atoms1.get_calculator()

                        #atoms2.calc._label="bulk2" #rename bulk2.
                        calc._label="bulk2" #rename bulk2.
                        #calc._set_atoms=True
                        atoms2.set_calculator(calc)
                        #print atoms2
                        x2=call_castep(atoms2,calc=calc)

                else:
                        x2=call_castep(atoms2,typ="sp",dipolCorr='None',name='bulk2',ENCUT=ecut,PP=pp,KPspacing=0.10) #normally use K-point spacing.

"""


def slab_aligner_old(slab1,slab2,L,Lmax,Lstep,ptol,T):

        sucess = False

        while L <= Lmax and sucess == False:
                print("trying with L is", L)
                angles2 = reasnoble_slab_angles(Lmax=L,slab=slab2)
                angles1 = reasnoble_slab_angles(Lmax=L,slab=slab1)	
                print("comparing {} possible pairs" .format(len(angles1)*len(angles2)))	
                #angles contains all pairs of cell vectors where both are shorter than Lmax
                if len(angles1) > 0 and len(angles2) > 0:
                        try:
                                choice =  match_angles(slab1.cell, angles1, slab2.cell, angles2, ptol=ptol, Lmax=L)
                                sucess = True
                        except:
                                pass	
                if sucess == False:
                        L += Lstep
        if sucess == False:
                print("not possible within these tolerances")
                exit()				

        #print "choice is ",choice

        #repeat slabs as specified
        #use 1 layer instead, when doing layer convergence test!!!
        crep = np.ceil(abs(T/np.dot(slab1.cell[2],(0,0,1)))) 
        slab1 = cut_cell(slab1,choice[2],choice[3],(0,0,crep))
        #slab1 = square_slab(slab1)

        crep = np.ceil(abs(T/np.dot(slab2.cell[2],(0,0,1))))
        slab2 = cut_cell(slab2,choice[4],choice[5],(0,0,crep))
        #slab2 = square_slab(slab2)



        #perform final alignments	
        slab1,slab2 = align_slab_axes(slab1,slab2,ptol)
        slab1,slab2 = final_handedness_flip(slab1,slab2)

        #output useul info
        print("slab 1")
        for line in slab1.cell:
                print(line, np.linalg.norm(line))

        print("slab 2")
        for line in slab2.cell:
                print(line, np.linalg.norm(line))	

        #confirm that atom densities are the same as at the start
        ri = number_density(atoms1)
        rf = number_density(slab1)
        pd = abs((ri-rf)/ri*100)
        print("number density of slab1 has changed by {} percent" .format(pd))

        ri = number_density(atoms2)
        rf = number_density(slab2)
        pd = abs((ri-rf)/ri*100)
        print("number density of slab2 has changed by {} percent" .format(pd))


        return slab1,slab2

