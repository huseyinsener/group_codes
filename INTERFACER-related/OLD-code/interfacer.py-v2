#!/usr/bin/env python
import numpy as np
import argparse
import ase.io
import ase
from ase.visualize import view
from os import system,popen,chdir
from re import search
from sys import exit
from ase.build import *
from ase import Atoms
import fractions
import ase.build
import copy
import time
import ase.build.tools
import matplotlib.pyplot as plt
import ase.calculators.castep
from spglib import find_primitive,standardize_cell,get_spacegroup #niggli_reduce from ASE-tools clashes with that from spglib.

from ase.spacegroup import crystal


"""LAST EDIT: jpd47 07/05/2017"""
def calc_R1(x1,y1):
        #gives a rotation matrix that will rotate x1 onto y1
        Id = np.array([[1,0,0],[0,1,0],[0,0,1]])
       	u = np.cross(x1,y1)
	
        tol = 0.001
        if np.linalg.norm(u) < tol:
                return Id

        sin_th = np.linalg.norm(u)/(np.linalg.norm(x1)*np.linalg.norm(y1))
        cos_th = np.dot(x1,y1)/(np.linalg.norm(x1)*np.linalg.norm(y1))
        u = u/np.linalg.norm(u)

        #use wiki formula for R1
        ux = np.array([[0,-u[2],u[1]],[u[2],0,-u[0]],[-u[1],u[0],0]])
        ut = np.tensordot(u,u,axes=0)
        R1 = cos_th*Id + sin_th*ux + (1-cos_th)*ut
        return(R1)

def rotate_slab(slab):
	d = slab.cell[0]
	e = slab.cell[1]
	f = slab.cell[2]
	frac_pos = slab.get_scaled_positions()
	R1 = calc_R1(np.cross(d,e),[0,0,1])
	
	slab.cell[0] = np.dot(R1,d)
	slab.cell[1] = np.dot(R1,e)
	slab.cell[2] = np.dot(R1,f)
	slab.set_scaled_positions(frac_pos)
	return slab

def lcm(a,b):
	return (a*b)//fractions.gcd(a,b)

def get_cut_vectors(miller, atoms_cell):
	#from miller indicies construct 2 lattice vectors in the required plane
	h,k,l = miller
	a = atoms_cell[0]
	b = atoms_cell[1]
	c = atoms_cell[2]
	zero_inds = np.argwhere(np.array(miller)==0)
	
	#no zero miler indicies
	if len(zero_inds) == 0:
		lm = lcm(h,l);	d = (lm/h,0,-lm/l)	#vector from c intersection to a
		lm = lcm(k,l);	e = (0,lm/k,-lm/l) 	#vector from c` intersection to b
		#pick f so that cell is left handed
		f = (0,0,1)
		origin = c*1.0/l
	
	elif len(zero_inds)==3:
		print("miller not a valid plane")
		raise ValueError

	#one zero milller index
	elif len(zero_inds)==1:
		#set d to be the axis that is in the plane	

		d = [0,0,0]
		d[int(zero_inds[0])] = 1

		#construct e from the other 2 vectors
		s = set((0,1,2))
		s.remove(int(zero_inds[0]))
		print("s is",s)
		H = s.pop()
		K = s.pop()
		lm = lcm(miller[H],miller[K])
		print(H,miller[H],K,miller[K],lm)
		e = [0,0,0]
		e[H] = lm/miller[H]
		e[K] = -lm/miller[K]
		print("e is", e)
		
		#pick f - could be improved...
		f = [0,0,0]
		f[H] = 1
		
		#pick origin
		origin = 1.0/miller[H] * atoms_cell[H]	
	

	#two zero miller indicies
	elif len(zero_inds)==2:
		d = [0,0,0]
		#print zero_inds
		d[zero_inds[0][0]] = 1
		e = [0,0,0]
		e[zero_inds[1][0]] = 1
		f_ind = np.argwhere(np.array(miller)!=0)[0][0]
		f = [0,0,0]
		f[f_ind] = 1
		origin = atoms_cell[f_ind]*1.0/miller[f_ind]	
		#print d,e,f
		#print origin

	#ensure that slab is always left handed	
	if np.dot(np.cross(d,e),f) < 0:
		f = -np.array(f)
	"""
	#pick f so that it points from the plane, away from the surface
	#origin in cartesians, e,f,d in indicies
	"""
	fc = f[0]*a + f[1]*b + f[2]*c
	if np.linalg.norm(origin+fc) < np.linalg.norm(origin):
		f  = np.array(f)
		f = -f
	
	dc = d[0]*a + d[1]*b + d[2]*c
	ec = e[0]*a + e[1]*b + e[2]*c
	if np.dot(np.cross(dc,ec),fc) < 0:
		t = d
		d = e
		e = t
	
	return d,e,f,origin

def wrap_coords(slab):
	sp = slab.get_scaled_positions()
	sp %= 1.0
	slab.set_scaled_positions(sp)
	return slab

def make_slab(miller, atoms,repeat=(1,1,1),square=False):
	#construct slab
	d,e,f,origin = get_cut_vectors(miller, atoms.cell)
	atoms = wrap_coords(atoms)
	#slab = ase.build.cut(atoms, d, e, f, origo=origin)
	slab = cut_cell(atoms, d, e, f, origin=origin)
	slab = slab.repeat(repeat)
	slab = rotate_slab(slab)
	slab = AG_slab(slab)
	
	if square:
		slab = square_slab(slab)
	#gives the slabs a consistent handedness
	#swaps a1,a2 after AG if necessary
	#maintains a3.(0,0,1) > 0
	if np.dot(slab.cell[2],np.cross(slab.cell[0],slab.cell[1])) < 0:
		slab = flip_handedness(slab)
	return slab

def square_slab(slab):
	#now set f perpendicular to surface, means can't make it thicker any more!
	#assumes that the slab is aligned with a3 perpendicular to (0,0,1)
	slab.cell[2][1] = 0
	slab.cell[2][0] = 0	
	slab = wrap_coords(slab)
	return slab

def acute_Guass(u,v):
        u = np.array(u)
        v = np.array(v)
        #start by making sure that u is smaller than v
        if np.linalg.norm(v) < np.linalg.norm(u):
                t = u;  u = v;  v = t;
        #calculate the shortest distance from v + a u to the origin
        epsilon = 10**-5
        while True:
                uhat = u/np.linalg.norm(u)
                vhat = v/np.linalg.norm(v)
                a = np.dot(uhat,vhat)
                a = round(a)
                v = v - a*u
                if (1-epsilon)*np.linalg.norm(u) < np.linalg.norm(v):
                        return(u,v)
                else:
                        t = u;  u = v;  v = t;

        return u,v
	
def basis_change(ab,uv,ruv):
	#ab is final basis, uv is current, ruv is r in uv
	#ab are tuples of basis vectors as rows
	#rab are the components of r in the ab basis
	A = np.transpose(ab);	#print(A)
	U = np.transpose(uv);	#print(U)
	M = np.dot(np.linalg.inv(A),U);	#print(M)
	rab = np.dot(M,ruv)
	return rab

def AG_slab(slab):
	a = [slab.cell[0][i] for i in range(0,2)]
	b = [slab.cell[1][i] for i in range(0,2)]
	a2,b2 = acute_Guass(a,b)
	a2_ab = basis_change([a,b],[a2,b2],[1,0])
	b2_ab = basis_change([a,b],[a2,b2],[0,1])
	#add the 0 to them so that they can be cut out
	a2_ab = np.append(a2_ab,0)	
	b2_ab = np.append(b2_ab,0)
	slab = cut_cell(slab,a2_ab,b2_ab,(0,0,1))
	return slab

def reasnoble_slab_angles(Lmax=10,slab=None):
	def filter_to_snp(abrep,a,b):
		#gets passed a list of vectors
		#filtere it down to non-parallel
		#taling the shortes option
		angtol = 0.000001
		lentol = 0.000001
		ahat = a*1.0/np.linalg.norm(a)
		vecs = []
		for x in abrep:
			v = a*x[0]+b*x[1]
			vn = np.linalg.norm(v)
			if abs(vn) <= lentol:
				continue
			ctheta = np.dot(v,ahat)/vn
			theta = np.arccos(ctheta)
			tested = False
			for i,y in enumerate(vecs):
				if (y[2]-angtol <= theta <= y[2] +angtol) or (y[2]-angtol <= np.pi - theta <= y[2]+angtol):
					tested = True
					if vn < y[3]:
						vecs[i] = [x[0],x[1],theta,vn,v]
					break
			if not tested:
				vecs.append([x[0],x[1],theta,vn,v])
			
		return vecs
	#creates a list of reasnoble slab angles,areas of those slabs
	#and slab vectors in terms of a,b
	#considering slab lengths below Lmax
	angles = []
	vecs = []
	
	a = [slab.cell[0][i] for i in range(0,2)]
	b = [slab.cell[1][i] for i in range(0,2)]
	a = np.array(a);	b = np.array(b);
	naMax = int(np.floor(Lmax/np.linalg.norm(a)))
	for na in range(0,naMax+1):
		A = na*a
		d_vec = A - (np.dot(A,b)*1.0/np.linalg.norm(b)**2)*b
		d = np.linalg.norm(d_vec)	

		if d < Lmax:
			#print  a, b, A, d_vec
			d_ab = basis_change([a,b],[[1,0],[0,1]],d_vec)
			nbf = np.round(d_ab[1])
			nbc = nbf + 1
			#add from nbc, until not within Lmax
			while np.linalg.norm(A + nbc*b) <= Lmax:
				vecs.append([na,nbc])
				nbc +=1
			#subtract from bvf, until not within Lmax
			while np.linalg.norm(A +nbf*b) <= Lmax:
				vecs.append([na,nbf])
				nbf -=1
				
	#filter vecs, removing those which are parallel
	vecs = filter_to_snp(vecs,a,b)
	for i,c1 in enumerate(vecs):
		for j in range(i,len(vecs)):
			c2 = vecs[j]
			v1 = c1[0]*a+c1[1]*b	
			v2 = c2[0]*a+c2[1]*b	
		
			if np.linalg.norm(v1) < 0.0001 or np.linalg.norm(v2) < 0.001:
				continue
			
			#make right handed
			v13 = [x for x in v1]; v13.append(0);	v13 = np.array(v13)
			v23 = [x for x in v2]; v23.append(0);	v23 = np.array(v23)
			
			if np.dot(slab.cell[2],np.cross(v13,v23)) > 0:
				d1 = [x	for x in c1]
				d2 = [x for x in c2]
			else:
				d1 = [x for x in c2]
				d2 = [x for x in c1]
				v1 = d1[0]*a+d1[1]*b	
				v2 = d2[0]*a+d2[1]*b	
			
			ctheta = np.dot(v1,v2)*1.0/(np.linalg.norm(v1)*np.linalg.norm(v2))
			if ctheta > 1-0.001 or ctheta < -1 + 0.001:
				continue
				
			Area = np.linalg.norm(np.cross(v1,v2))
			theta = np.arccos(ctheta)
			
			#add so that the slab is acute and right-handed
			#f right angle add both options	
			if theta < np.pi/2 - 0.01:
				angles.append([theta,Area,[d1[0],d1[1]],[d2[0],d2[1]]])
			elif theta > np.pi/2 + 0.01:
				angles.append([np.pi-theta,Area,[-d2[0],-d2[1]],[d1[0],d1[1]]])
			else:
				angles.append([theta,Area,[d1[0],d1[1]],[d2[0],d2[1]]])
				angles.append([np.pi-theta,Area,[-d2[0],-d2[1]],[d1[0],d1[1]]])
	return angles

def LCM_float(x,y,Lmax,ptol):
	#find nx -ny <=tol
	"""VERY VERY SHITTY WAY OF DOING THIS LOLOOLOL"""
	swap = False
	tol = 0.001
	if x < y:
		t = x;	x = y; y = t;	
		swap = True
	Nxmax = int(np.ceil(Lmax*1.0/x))
	Nymax = int(np.ceil(Lmax*1.0/y))
	for nx in range(1,Nxmax):
		ny = 1;
		X = nx*x; Y = y
		while X >= Y-tol and ny < Nymax:
			Y = ny*y
			pd = abs(X-Y)*100.0/X
			if pd < ptol:
				if not swap:
					return True,nx,ny
				else:
					return True,ny,nx
		
			ny += 1
	return False,0,0

def flip_handedness(atoms):
	pos = atoms.positions
	sp = atoms.get_scaled_positions()
	cell = [line for line in atoms.cell]
	#swap a and b then swap scaled positions
	temp = cell[0]
	cell[0] = cell[1];	cell[1] = temp
	atoms.cell = cell
	swsp = [[x[1], x[0], x[2]] for x in sp]
	atoms.set_scaled_positions(swsp)
	return atoms


def match_angles2(slab1_cell, angles1, slab2_cell, angles2, ptol=2.0, Lmax=15):
	matches = []
	for ang1 in angles1:
		for ang2 in angles2:
			pd = 100*abs(ang1[0]-ang2[0])/float(ang1[0])
			if pd > ptol:
				continue
			
			a1 = ang1[2][0]*slab1_cell[0] + ang1[2][1]*slab1_cell[1]
			a2 = ang1[3][0]*slab1_cell[0] + ang1[3][1]*slab1_cell[1]
			b1 = ang2[2][0]*slab2_cell[0] + ang2[2][1]*slab2_cell[1]
			b2 = ang2[3][0]*slab2_cell[0] + ang2[3][1]*slab2_cell[1]
			theta_check1 = np.arccos(np.dot(a1,a2)/(np.linalg.norm(a1)*np.linalg.norm(a2)))	
			theta_check2 = np.arccos(np.dot(b1,b2)/(np.linalg.norm(b1)*np.linalg.norm(b2)))	
			
			match1,na1,nb1 = LCM_float(np.linalg.norm(a1),np.linalg.norm(b1),Lmax,ptol)
			if match1:
				match2, na2,nb2 = LCM_float(np.linalg.norm(a2),np.linalg.norm(b2),Lmax,ptol)
				if match2:
					Area = np.linalg.norm(np.cross(a1,a2))*na1*na2
					theta = 0.5*(ang1[0]+ang2[0])
					#print(ang1[0],ang2[0],theta_check1,theta_check2)
					A1 = (ang1[2][0]*na1,ang1[2][1]*na1,0)
					A2 = (ang1[3][0]*na2,ang1[3][1]*na2,0)
					B1 = (ang2[2][0]*nb1,ang2[2][1]*nb1,0)
					B2 = (ang2[3][0]*nb2,ang2[3][1]*nb2,0)
					match = [Area,theta,A1,A2,B1,B2]
					matches.append(match)
	
	#filter the matches based on area on and theta	
	matches = sorted(matches,key=lambda a_entry: a_entry[0])
			
	def filter_matches(matches):
		print "selecting best match based on Area and sin(theta) from {} choices" .format(len(matches))
		A = matches[0][0]
		stheta = np.sin(matches[0][1])
		best  = matches.pop(0)
		ftol = 0.001
		for x in matches:
			if x[0] <= A + ftol and np.sin(x[1]) > stheta:
				A = x[0]
				stheta = np.sin(x[1])
				best = x
		return best
	best = filter_matches(matches)	
	return best
					
def plot_slab_axes(slab1,slab2):
	ax = plt.axes()
	def plot_arrow(Offset,vec,ax,c):
		ax.arrow(Offset,Offset,vec[0],vec[1],head_width=0.05,head_length=0.1,fc=c,ec=c)
		ax.set_xlim((-40,40))
		ax.set_ylim((-40,40))			
		return ax

	ax = plot_arrow(1,slab1.cell[0],ax,"b")
	ax = plot_arrow(1,slab1.cell[1],ax,"k")
	ax = plot_arrow(0,slab2.cell[0],ax,"r")
	ax = plot_arrow(0,slab2.cell[1],ax,"g")
	plt.show()

def cut_cell(atoms,a1,a2,a3,origin=(0,0,0)):
	tol = 10**-7
	sp = atoms.get_scaled_positions()

	for i,x in enumerate(sp):
		for j,y in enumerate(x):
			y %= 1
			if y >= 1 - tol:
				sp[i][j] = tol
			elif y <= tol:
				sp[i][j] = tol
			
	atoms.set_scaled_positions(sp)
	atoms2 = ase.build.cut(atoms,a1,a2,a3,origo=origin,tolerance=10**-3*tol)
	
	atom_density_check(atoms,atoms2)	
	return atoms2

def number_density(slab):
	N = len(slab.positions)
	a1 = slab.cell[0]
	a2 = slab.cell[1]
	a3 = slab.cell[2]
	V = abs(np.dot(a3,np.cross(a1,a2)))
	return N*1.0/V

def RH(slab):
	#swaps a1 and a2 to make the slab right handed
	a = [line for line in slab.cell]
	fp = slab.get_scaled_positions()
	fp2 = [[u[1],u[0],u[2]] for u in fp]
	if np.dot(a[2],np.cross(a[0],a[1])) < 0:
		t = a[0];	a[0]= a[1];	a[1] = t;
	slab.cell = a
	slab.set_scaled_positions(fp2)
	return slab

def invert_axis(slab,axis):
	#flips the sign of one of the slabs axis
	#scaled coords adjusted accordingly
	sp = slab.get_scaled_positions()
	sp2 = []
	for line in sp:
		l2 = [x for x in line]
		l2[axis] = 1-l2[axis]
		sp2.append(l2)
	slab.cell[axis] = -slab.cell[axis]
	slab.set_scaled_positions(sp2)
	return slab

def bot_to_top(slab):
	#rotates by 180 degress then inverts and makes right handed
	R = np.array([[1,0,0],[0,-1,0],[0,0,-1]])
	fp = slab.get_scaled_positions()
	cell = [np.dot(R,slab.cell[i]) for i in range(0,3)]
	slab.cell = cell
	slab.set_scaled_positions(fp)		

	#invert the z axis
	slab = invert_axis(slab,2)

	#force to be right handed
	slab = RH(slab)		
	return slab

def print_cell(slab1):
	#print out the cells for the slabs
	for line in slab1.cell:
		print(line,np.linalg.norm(line))

def atom_density_check(atoms,slab):
	#check that the atom densities haven't been changed
	ri = number_density(atoms)
	rf = number_density(slab)
	pd = abs((ri-rf)/ri*100)
	if pd > 10**-4:
		print "number density of slab1 has changed by {} percent" .format(pd)
		print "exiting due to change in atom density..."

def find_commensurate_supercell(slab1,slab2,Lmax,Lstep,ptol):
	#loop over Ls increasing util finding a commensurate supercell
	sucess = False
	L = Lstep
	while L <= Lmax and sucess == False:
		print "trying with L is", L
		angles2 = reasnoble_slab_angles(Lmax=L,slab=slab2)
		angles1 = reasnoble_slab_angles(Lmax=L,slab=slab1)	
		print "comparing {} possible pairs" .format(len(angles1)*len(angles2))	
		#angles contains all pairs of cell vectors where both are shorter than Lma
		if len(angles1) > 0 and len(angles2) > 0:
			try:
				choice =  match_angles2(slab1.cell, angles1, slab2.cell, angles2, ptol=ptol, Lmax=L)
				sucess = True
			except:
				pass	
		if sucess == False:
			L += Lstep
	if sucess == False:
		print "not possible within these tolerances"
		exit()				
	return choice

####################################
# End of Surface Slab Creator Part #
####################################


def misfit(slab1,slab2,ptol=2,ifPlot=False): #Computes the misfit parameter between two slabs. (see Surf. Interface Anal. 2003, 35, 835-841. )
        #Assuimng that two slabs are well aligned, overlap area should be equalt to smaller one's surface area.
        #align_slab_axes(slab1,slab2,ptol)
        #A1 = np.linalg.norm(np.cross(slab1.cell[0],slab1.cell[1]))
        #A2 = np.linalg.norm(np.cross(slab2.cell[0],slab2.cell[1]))
        A1=surf_area(slab1);A2=surf_area(slab2)
        #print A1,A2
        if ifPlot: plot_slab_axes(slab1,slab2)
        return 1 - 2*min(A1,A2)/(A1+A2)

def surf_area(slab1):
        return np.linalg.norm(np.cross(slab1.cell[0],slab1.cell[1]))

def volume(cell):
        return np.abs(np.dot(cell[2], np.cross(cell[0], cell[1])))

def get_fu(atoms):
        aTypes=atoms.get_chemical_symbols()
        atoms={}
        #print aTypes
        for at in aTypes:
            #print ln
            #at=ln.split()[0]
            if not atoms.has_key(at):atoms[at]=1
            else: atoms[at]+=1
        

        keys=atoms.keys()
        keys.sort()
        content=""
        for key in keys:
                content+=key
                if atoms[key]!=1:content+=str(atoms[key])

        #Determine the formula unit.

        try:
                fu=1
                vals=atoms.values()
                for i in range(2,min(vals)+1):
                        fl=1
                        for j in vals:
                                if j%i!=0:fl=0
                        if fl:fu=i
        #print fu
        except: print "Error in fu determination, fu set to 1";   fu=1
    
        return fu

def conv_layers(atoms,ifPlot=False,ifPrim=False):#layer convergence test (Input atoms with a calc object). 
        #print "Convergence of E/atom vs. #layers"
        Etol=1e-2 #eV/atom
        Ftol=5e-2 #eV/Angstroem
        Estr=0.1 #GPa

        
        #Initial values
        E=[0]; F=[0]; S=[0]
        atoms_orig=atoms.copy()
        calc=atoms.get_calculator()
        
        #find the primitive cells to reduce comp. efforts.
        if ifPrim: atoms=find_prim(atoms);atoms.set_calculator(calc)
        
        atoms.center(vacuum=4.0, axis=2)
        nAt=atoms.get_number_of_atoms()
        E.append(atoms.get_potential_energy()/nAt)
        i=1;layers=[1]
        while abs(E[i]-E[i-1]) > Etol:
                layers.append(1+1*i)
                atoms=atoms_orig.copy()
                atoms=atoms.repeat((1,1,layers[-1]))
                atoms.center(vacuum=4.0, axis=2)
                atoms.set_calculator(calc)
                #view(atoms)
                nAt=atoms.get_number_of_atoms()
                E.append(atoms.get_potential_energy()/nAt)
                print "Iter. #%d, #layers: %d, #atoms: %d "%(i,layers[-1],nAt)
                print "deltaE: %.3e eV/atom; target: %.3e eV."%(abs(E[i]-E[i-1]),Etol)
                i += 1
        print "conv_layers: E/atom converged to %.2f eV with %d layers."%(Etol,layers[-1])
        if ifPlot: #Do plotting of E/atom vs. #layers
                plt.plot(layers,E[1:], 'ko-')
                plt.xlabel('Number of layers')
                plt.ylabel('Energy per atom (eV/atom)')
                #plt.savefig('layer-conv.png')
                plt.show()
                
        return layers[-1],E[-1]*nAt,atoms
                

def find_prim(atoms,tol=1e-4):#using SPGlib find primitive cell of a given atoms object.
        scaled_positions= atoms.get_scaled_positions()#(wrap=True) 
        cell=(atoms.cell, scaled_positions, atoms.numbers)
        #print cell
        print "Space group of the given cell using tolerance=%f: %s"%(tol,get_spacegroup(cell,symprec=tol))
        lattice, scaled_positions, numbers = find_primitive(cell, symprec=tol)
        #lattice, scaled_positions, numbers = standardize_cell(cell, to_primitive=True, no_idealize=False, symprec=tol)
        atoms2=Atoms(symbols=numbers,cell=lattice,scaled_positions=scaled_positions,pbc=True)
        return atoms2

def call_castep(atoms,calc=None, typ="sp",PP='',wDir='./CASTEP-tmp',name='try',param='opt.param',resDir="",dipolCorr=False,dipolDir='z',KPgrid="1 1 1",KPspacing="", ifPrint=False,ifDryRun=False,ENCUT=0,ifManualRun=True):

    exe="mpirun -n 4 castep";PP_path='/rscratch/bk393/pspots/CASTEP'
    #system("export CASTEP_COMMAND='%s'"%exe)
    #system("export CASTEP_COMMAND='mpirun -n 4 castep'")
    #system("export CASTEP_PP_PATH='%s'"%PP_path)

    if calc!=None:
            #This is good for assiging the settings from a previously created Calculator object (i.e. not to repeat all the settings the second time). None of the other options will be taken into account.
            atoms.set_calculator(calc)
            #manual CASTEP run icin ayri bir function yap ve burda ve asagida cagir.
            return atoms

    calc = ase.calculators.castep.Castep()

    #Assign the environment variables.
    calc._castep_command=exe
    calc._castep_pp_path=PP_path
    
    # include interface settings in .param file
    calc._export_settings = True

    # reuse the same directory
    calc._directory = wDir
    calc._rename_existing_dir = False
    calc._label = name

    
    if param:
        #Read paramters from param file input.
        calc.merge_param(param)
    else:        
        # Use default param settings (depreceated)
        calc.param.xc_functional = 'PBE'
        calc.param.cut_off_energy = 100 #500
        calc.param.num_dump_cycles = 0
        calc.param.geom_method = "lbfgs"
        calc.param.geom_max_iter= 10
        calc.param.write_cell_structure=True
        calc.param.spin_polarised=False
        calc.param.opt_strategy="speed"
        calc.param.mix_history_length=20
        calc.param.max_scf_cycles=100
        calc.param.calculate_stress=True
        #calc.param.finite_basis_corr=0
    
    # Cell settings
    #
    calc.cell.symmetry_generate=True
    calc.cell.snap_to_symmetry=True
    if KPspacing:calc.cell.kpoints_mp_spacing = str(KPspacing) #default=0.05 2pi*eV/A
    else: calc.cell.kpoint_mp_grid = KPgrid #def='1 1 1'
    
    #calc.cell.fix_com = False
    #calc.cell.fix_all_cell = True

     
    #This overwrites the task paramter from the param input.
    if typ.lower()=="sp":    calc.param.task = 'SinglePoint'
    elif typ.lower()=="geom":calc.Task = 'GeometryOptimization'
    
    if dipolCorr: #def: No dipole corrections. 
        if dipolCorr=="SC": calc.param.dipole_correction= "SELFCONSISTENT"
        elif dipolCorr=="static": calc.param.dipole_correction= "static"
        else: calc.param.dipole_correction= "None"
        calc.param.dipole_dir=dipolDir #options: x,y,z and a (only energy-corr)

        
    
    #calc.initialize()#Creates all needed input in the _directory. (Not needed for actual run.)
    atoms.set_calculator(calc)  #Set for the previously created interface

    if ENCUT!=0: calc.param.cut_off_energy=ENCUT
    
    if PP!="":#otherwise on-the-fly(OTF) is used as default
        fnc=str(calc.param.xc_functional).split("\n")[1].upper()
        #print fnc
        PP=PP.upper()
        #print PP.lower().find(str(calc.param.xc_functional).lower())
        if PP != "OTF" and  PP.find(fnc)== -1:
                print "There is a problem with the pseudopotential choice. \nSelected PP does not match with XC functional being used: ",PP,fnc
                exit()
        elif PP=="OTF": None #default is OTF anyway.
        else: atoms.calc.set_pspot(PP)  #This automatically sets the pseudo-potential for all present species to <Species>_<library>.usp. Make sure that _castep_pp_path is set correctly in the shell.


    # Or Read all settings from previous calculation
    if resDir != "": #Does not read from checkpoint file for some reason, needs to be checked !!
        # Reset to CASTEP default
        #atoms.calc.param.task.clear()
        atoms = ase.io.castep.read_seed('%s/%s' % (wDir,name))
        calc.param.reuse=True
        calc.param._try_reuse=True
        calc._export_settings = True
        #print atoms.calc,"bora\n\n",calc
        
    if ifPrint:print (calc) #prints calculation summary.

    # necessary for tasks with changing positions
    # such as GeometryOptimization or MolecularDynamics (This option does not work as deisgnated !!! The atomic coords are not updated at the end of the geom. opt. unlike the energy.
    calc._set_atoms = True
    atoms.calc._set_atoms = True
    
    
    # Check for correct input
    if not ifDryRun:
            if ifManualRun: #If a manual run of the CASTEP is needed.
                    #str1="%s %s/%s"%(exe,wDir,name)
                    str1="%s %s"%(exe,name)
                    print "Running ",str1
                    calc._copy_pspots=True
                    calc.initialize()

                    chdir(wDir)
                    
                    system(str1) #PSPOT missing in the folder
                    #x=parseCASTEP("%s/%s.geom"%(wDir,name),atoms=atoms)
                    x=parseCASTEP("%s.geom"%(name),atoms=atoms)
                    chdir("..")
                    return x
                    
            else: #CASTEP calculation is not done here. It will be called in the main script, when trying to reach the attributes, e.g. atoms.get_potential_energy().
                    return atoms
    else:
            if calc.dryrun_ok():

                    return atoms
            else:
                    print("CASTEP run: Found error in input")
                    print(calc._error)
                    return None
            
def parseCASTEP(fname,atoms=None):
        #Read the CASTEP output to retrieve final 0K energy, atomic coords (Cart. and fractional), and forces.
        bohr2ang=0.52917721
        Ha2eV=27.211386
        atP2GPa=0.29421912e5 #P in atomic units to GPa.
        E=0.0;H=0.0 #Total Energy and Enthalpy
        h=[] #unit cell vectors
        s=[] # stress tensor
        xyz=[] #Cartesian atomic coords.
        fract=[] #fractional atomic coords.

        print "Parsing ",fname
        if fname.split(".")[1]=="geom":
                try: tSteps=len(popen("grep '<-- c' %s"%fname).readlines())-1
                except:tSteps=0

                flag=0
                for ln in open(fname,'r').readlines():
                        ln=ln[0:-1]
                        if not flag and search("<-- c",ln):
                                if int(ln.split()[0])==tSteps:
                                        #print 'here'
                                        flag=1
                        elif flag:
                                if search("<-- E",ln):E=float(ln.split()[1])*Ha2eV; H=float(ln.split()[1])*Ha2eV
                                elif search("<-- h",ln): h.append([float(i)*bohr2ang for i in ln.split()[0:3]])
                                elif search("<-- S",ln): s.append([float(i)*atP2GPa for i in ln.split()[0:3]])
                                elif search("<-- R",ln): xyz.append([float(i)*bohr2ang for i in ln.split()[2:5]])
                                elif search("<-- F",ln): fract.append([float(i)*bohr2ang for i in ln.split()[2:5]])
                                
                                
       
        elif fname.split(".")[1]=="castep":
                None
                   #TAMAMLA!!!!
                   
        if atoms != None:
                #print np.array(h),np.array(s),np.array(xyz),np.array(fract)
                atoms.set_cell(np.array(h))
                atoms.set_positions(np.array(xyz))
                atoms.set_scaled_positions(np.array(xyz)) #wheether to use both ast?
                return E, H, s, atoms
        else:
                #Energy, Enthalpy, stress tensor, Cart coords, fractional coords, atoms object.
                return E, H, s, xyz, fract, atoms
        
                

def get_interface_energy(slab1,slab2,Ebulk1,Ebulk2,dist=1.0,convLayers=False): #Input is slab1,slab2 as Atoms object with a calculator property assigned.
        if not slab2.has(calc):
                calc=slab1.get_calculator()
                slab2.set_calculator(calc)
        
        if convLayers: #A layer convergence test is done here!.
                print "Layer convergence test is switched on."
                #slab1.set_calculator(calc)
                slab1=call_castep(slab1,typ="SP",dipolCorr='SC',name='slab1',ENCUT=ecut,KPgrid='1 1 1',PP=pp) #Use SP for efficiecy.
                calc=slab1.get_calculator()       
                print "Working on slab 1."
                nl1,Eslab1,slab1=conv_layers(slab1)#,ifPrim=1)  #Vacuum layer is added automatically within the function.
                fu1=get_fu(slab1)
                
                #slab2=call_castep(slab2,typ="SP",dipolCorr='SC',name='slab2',ENCUT=ecut,KPgrid='1 1 1',PP=pp)
                
                slab2.set_calculator(calc)
                slab2.calc._label="slab2"    #change name for slab2
                print "Working on slab 2."                
                nl2,Eslab2,slab2=conv_layers(slab2)#,ifPrim=1)

                fu2=get_fu(slab2)
                print nl1,nl2,Eslab1,Eslab2,fu1,fu2

        else:
                slab1_vac=slab1.copy();slab2_vac=slab2.copy();
                slab1_vac.center(vacuum=4.0, axis=2)
                slab2_vac.center(vacuum=4.0, axis=2)
                #atoms=call_castep(slab1_vac,typ="SP",dipolCorr='SC',name='slab1',ENCUT=ecut,KPgrid='1 1 1',PP=pp)
                atoms=slab1_vac
                atoms.set_calculator(calc)
                Eslab1=atoms.get_potential_energy()
                fu1=get_fu(atoms)
                
                #atoms=call_castep(slab2_vac,typ="SP",dipolCorr='SC',name='slab2',ENCUT=ecut,KPgrid='1 1 1',PP=pp)
                atoms=slab2_vac
                atoms.set_calculator(calc)
                atoms.calc._label="slab2"
                Eslab2=atoms.get_potential_energy()
                fu2=get_fu(atoms)

        #view(slab1.repeat((2,2,1)))
        #view(slab2.repeat((2,2,1)))
        ase.io.write("slab1.cell",slab1.repeat((2,2,1)),format='castep-cell')
        ase.io.write("slab2.cell",slab2.repeat((2,2,1)),format='castep-cell')
        #ase.io.write("slab11.cell",slab1a,format='castep-cell')

        Ws1=(Eslab1-fu1*Ebulk1)/2/surf_area(slab1)/0.01 #A2 to nm2
        Ws2=(Eslab2-fu2*Ebulk2)/2/surf_area(slab2)/0.01 #A2 to nm2
        
        print('%s: %s eV' % ('Ebulk 1', Ebulk1))
        print('%s: %s eV' % ('Ebulk 2', Ebulk2))
        print('%s: %s eV' % ('Eslab 1', Eslab1))
        print('%s: %s eV' % ('Eslab 2', Eslab2))
        print('%s: %.2f eV/nm^2' % ('Wsurf 1', Ws1))
        print('%s: %.2f eV/nm^2' % ('Wsurf 2', Ws2))

        #exit()
        
        #Interface before alignment.
        print "Creating the interface with given slabs."
        int1=ase.build.stack(slab1, slab2, axis=2, maxstrain=None, distance=dist,cell=None,reorder=True)
        int1.center(vacuum=4.0,axis=2)
        view(int1)
        ase.io.write("interface1.cell",int1.repeat((2,2,1)),format='castep-cell')
        atoms=call_castep(slab1_vac,typ="SP",dipolCorr='SC',name='int1',ENCUT=500,KPgrid='1 1 1',PP=pp)
        #atoms=int1
        #atoms.set_calculator(calc)
        Eint=atoms.get_potential_energy()

        #Wad=(Ws1+Ws2-Eint)/surf_area(int1)/0.01 #A2 to nm2 #check the formula Ea isntead of Wsurf?? This is wrong
        #print('Wad before alingment: %.2f eV/nm^2'%Wad)

        Wad=(Eslab1+Eslab2-Eint)/surf_area(int1)/0.01 #A2 to nm2 #check the formula Ea isntead of Wsurf??
        
        print('W_ad before alingment: %.2f eV/nm^2'%Wad)
        return Eslab1,Eslab2,Ws1,Ws2,int1#surf_area(int1)


##################################################
#                  MAIN METHOD                   #
##################################################
               
if __name__== '__main__':
	#read in arguments
	parser = argparse.ArgumentParser()
	parser.add_argument("-i1", "--infile1", default="Li.cell")
	parser.add_argument("-o", "--outfile")
	parser.add_argument("-i2", "--infile2", default="Al.cell")
	parser.add_argument("-m1","--miller1", default=(1,0,0), nargs="+", type=int)
	parser.add_argument("-m2","--miller2", default=(1,0,0), nargs="+", type=int)
        parser.add_argument("-msd","--max_slab_dimension",default=100)
	parser.add_argument("-t","--thickness",default=4,type=float)
	parser.add_argument("-pt","--percentage_tolerance",default=4)
	args = parser.parse_args()

	infile1 = args.infile1
	miller1 = tuple(args.miller1)
	infile2= args.infile2
	miller2 = tuple(args.miller2)
	if args.outfile:
		outfile = args.outfile
	else:
		outfile ="interfaces.out"
	
	#tolerances
	Lmax = args.max_slab_dimension 	#max length of cell sides
	L = 5 # initial length
	Lstep = 10
	#T = 1.5	#thickness of slabs
        T=args.thickness
	ptol = args.percentage_tolerance	#percentage tolerances for angle and length matching

        ecut=300 #cutoff energy in eV
        pp="00PBE" #pseudopt to use in CASTEP calcs.Def (pp=""): OTF
        dirr="./CASTEP-tmp"
        
	#read in atoms and construct slab, need to repeat atoms to make view work
        print "Reading data from %s and %s."%(infile1,infile2)
        if infile1.split(".")[1]=="cell":
	        atoms1 = ase.io.read(infile1, format='castep-cell')
        elif infile1.split(".")[1]=="cif":
	        atoms1 = ase.io.read(infile1, format='cif')
        if infile2.split(".")[1]=="cell":
	        atoms2 = ase.io.read(infile2, format='castep-cell')
        elif infile2.split(".")[1]=="cif":
	        atoms2 = ase.io.read(infile2, format='cif')            

        #ase.build.bulk(name, crystalstructure=None, a=None, c=None, covera=None, u=None, orthorhombic=False, cubic=False)
        #atoms1=ase.build.bulk('Li','bcc', orthorhombic=True,cubic=True)
        
        print "Structure 1: %s with fu=%d"%(atoms1.get_chemical_formula(),get_fu(atoms1))
        print "Structure 2: %s with fu=%d"%(atoms2.get_chemical_formula(),get_fu(atoms2))

        if 0: atoms1=find_prim(atoms1); atoms2=find_prim(atoms2) #Whether to use primitive cells of input structures.
        
        #Get the bulk energy per formula unit.
        system("rm -f CASTEP-tmp/*")

        if 1:  # whether to compute energies/structures
                print "Computing bulk 1 energy."
                x=call_castep(atoms1,typ="geom",dipolCorr='None',name='bulk1',ENCUT=ecut,PP=pp,KPspacing=0.10) #normally use K-point spacing.
                atoms1=x[-1]
                Ebulk1=x[0]
                                                               
                fu1=get_fu(atoms1)
                sa1=surf_area(atoms1)
                Ebulk1 /= fu1


                
                print "Computing bulk 2 energy."

                if 0: #use the same settings as for bulk 1. #does not work
                        calc=atoms1.get_calculator()
                        
                        #atoms2.calc._label="bulk2" #rename bulk2.
                        calc._label="bulk2" #rename bulk2.
                        #calc._set_atoms=True
                        atoms2.set_calculator(calc)
                        #print atoms2
                        x=call_castep(atoms2,calc=calc)
 
                else:
                        x=call_castep(atoms2,typ="geom",dipolCorr='None',name='bulk2',ENCUT=ecut,PP=pp,KPspacing=0.10) #normally use K-point spacing.
 
        
                atoms2=x[-1]
                Ebulk2=x[0]
                #print  "atoms2"
                fu2=get_fu(atoms2)
                Ebulk2 /= fu2
                sa2=surf_area(atoms2)

                #print Ebulk1,Ebulk2
                #print fu1,fu2
                #print sa1,sa2
                
                #exit()        

        #Create the intial slabs with given Miller indices (before alignment).
        print "Creating the initial slabs."
        slab1 = make_slab(miller1,atoms1,repeat=(1,1,1),square=False)
	slab2 = make_slab(miller2,atoms2,repeat=(1,1,1),square=False)
        #slab1 = square_slab(slab1) #Not originally here. does not work properly here.
        if 1: #to calculate energies/structures
                at=call_castep(slab1,typ="geom",dipolCorr='SC',name='slab1',ENCUT=ecut,KPgrid='1 1 1',PP=pp)
                #calc=at.get_calculator()


        niggli=0
        #Not originally here. (Helps increase the overlab between surfaces. i.e. lower lattice misfit).
        if niggli: niggli_reduce(slab1);niggli_reduce(slab2)
        if 0: slab1=find_prim(slab1);slab2=find_prim(slab2) #does not work.
        
        ase.io.write("slab1.cell",slab1.repeat((2,2,1)),format='castep-cell')
        ase.io.write("slab2.cell",slab2.repeat((2,2,1)),format='castep-cell')
        #Interface before alignment. (this part should be moved to get_int.. func).
        print "Creating the interface with given slabs."
        int1=ase.build.stack(slab1, slab2, axis=2, maxstrain=None, distance=1.0,cell=None,reorder=True)
        int1.center(vacuum=4.0,axis=2)
        #view(int1)
        ase.io.write("interface1.cell",int1.repeat((2,2,1)),format='castep-cell')
        ase.io.write("interface1.cif",int1.repeat((2,2,1)),format='cif')
        #print get_interface_energy(slab1,slab2,Ebulk1,Ebulk2)
        
        #exit()


        ######################
        # Alignment of Slabs #
        ######################
        
	sucess = False
	while L <= Lmax and sucess == False:
		print "trying with L is", L
		angles2 = reasnoble_slab_angles(Lmax=L,slab=slab2)
		angles1 = reasnoble_slab_angles(Lmax=L,slab=slab1)	
		print "comparing {} possible pairs" .format(len(angles1)*len(angles2))	
		#angles contains all pairs of cell vectors where both are shorter than Lmax
		if len(angles1) > 0 and len(angles2) > 0:
			try:
				choice =  match_angles(slab1.cell, angles1, slab2.cell, angles2, ptol=2, Lmax=L)
				sucess = True
			except:
				pass	
		if sucess == False:
			L += Lstep
	if sucess == False:
		print "not possible within these tolerances"
		exit()				
		
		

	print "choice is ",choice

	#repeat slabs as specified
	crep = np.ceil(abs(T/np.dot(slab1.cell[2],(0,0,1))))
	slab1 = cut_cell(slab1,choice[2],choice[3],(0,0,crep))
	slab1 = square_slab(slab1)

	crep = np.ceil(abs(T/np.dot(slab2.cell[2],(0,0,1))))
	slab2 = cut_cell(slab2,choice[4],choice[5],(0,0,crep))
	slab2 = square_slab(slab2)
	


	#perform final alignments	
	slab1,slab2 = align_slab_axes(slab1,slab2,ptol)
	slab1,slab2 = final_handedness_flip(slab1,slab2)

	#output useul info
	print "slab 1"
	for line in slab1.cell:
		print line, np.linalg.norm(line)

	print "slab 2"
	for line in slab2.cell:
		print line, np.linalg.norm(line)	

	#confirm that atom densities are the same as at the start
	ri = number_density(atoms1)
	rf = number_density(slab1)
	pd = abs((ri-rf)/ri*100)
	print "number density of slab1 has changed by {} percent" .format(pd)
	
	ri = number_density(atoms2)
	rf = number_density(slab2)
	pd = abs((ri-rf)/ri*100)
	print "number density of slab2 has changed by {} percent" .format(pd)



        #Compute the surfafce energies.

        #try ase.geometry.get_layers(atoms, miller, tolerance=0.001)



        

        #Create the interface.
        interface=ase.build.stack(slab1, slab2, axis=2, maxstrain=None, distance=1.0,cell=None,reorder=True)
        #interface = wrap_coords(interface)
        #interface.wrap()
        interface.center(vacuum=4.0, axis=2) #Vacuum on both sides. For dipole corrections at least 8A vacuum is needed.

        #view(slab1.repeat((1,1,1)))
        ase.io.write("slab1a.cell",slab1,format='castep-cell')
        ase.io.write("slab2a.cell",slab2,format='castep-cell')

        if niggli: niggli_reduce(interface)
	view(interface)
        ase.io.write("interface.cell",interface,format='castep-cell')
        #ase.io.write("interface.cif",interface,format='cif')
        
        #plt.show()
        print "Misfit (mu) of slabs 1 and 2: %.3e"%misfit(slab1,slab2)#,ifPlot=1)
        
        exit()





        


        #typ=sp or typ=geom
        atoms=call_castep(interface,typ="sp",name='run1')
        #atoms.calc._pedantic=True
        print('%s: %s ' % ('Ep without dipole corr', atoms.get_potential_energy()))
        #atoms.calc.param.reuse = True  #needs check file to be present.
        #atoms.calc._try_reuse=True #does not help.
        #atoms=call_castep(interface,typ="SP",name='run1',resDir="./CASTEP-tmp")
        #print('%s: %s ' % ('E', atoms.get_total_energy())) #CASTEP calc. is repeated every time !!

        exit()
        atoms=call_castep(interface,typ="SP",dipolCorr='SC',name='run2')
        print('%s: %s ' % ('Ep with dipole corr', atoms.get_potential_energy()))
        
       
        #get_potential_energy()=get_total_energy() for castep.
        
        #print('%s : %s ' % (atoms.calc._label, atoms.get_dipole_moment()))
        #print('%s : %s ' % (atoms.calc._label, atoms.get_charges()))
        
        """get_potential_energy()
        get_potential_energies()
        get_forces()
        get_stress()
        get_stresses()
        get_total_energy()
        get_magnetic_moments()
        get_magnetic_moment()
        """
        exit()
        
        #One should also check the strain when creating the interface.
        interface = ase.build.stack(slab1, slab2, axis=2, maxstrain=2, distance=1.0,cell=None,reorder=True)
        interface.wrap()
        interface.center(vacuum=7.5, axis=2)
	view(interface)
	

##################
# Excluded Parts #
##################

        #Setting system variables inside the Python code deos not work. Has to be done in the shell.
        #exe="mpirun -n 4 castep"; PP_path='/rscratch/bk393/pspots/CASTEP'
        #system("export CASTEP_COMMAND='%s'"%exe)
        #system("export CASTEP_COMMAND='mpirun -n 4 castep'")
        #system("export CASTEP_PP_PATH='%s'"%PP_path)


        #Randomise atomic positions (not needed).
        #slab1.rattle(stdev=0.3) #def: 0.001
        #slab2.rattle(stdev=0.3) #def: 0.001


                #atoms1.calc._set_atoms=True
        #print atoms1.calc
        #Ebulk1=atoms1.get_potential_energy() #returns 0K energy (E-0.5TS).
        
        #print Ebulk1
        #print atoms1.get_potential_energy(force_consistent=True) #returns free enrergy (E-TS) 
        #print atoms1.get_total_energy()  #same as potential energy (E-0.5TS).
        #print atoms1.get_positions()
        #print atoms1.get_scaled_positions()
        #This does the geoemtry optimization and gets the final energy however the atomic positions (Cart or fractional) are not updated (even using the ._set_atoms=True option !!! This alos applies to get_total_energy etc. CASTEP must be run by hand and the output must be parsed (use _prepare_input_only option for CASTEP input files)!!! No problem with SP as no update on atomic coords.


        Li = bcc110("Li", (4, 4, 6)) #This one is the lowest surface.No of repetitions.
        #Li = surface('Li', (1, 1, 0), 3)#,10) #You don't have to know about the type fcc,hcp, etc. 
        Li.center(vacuum=10, axis=2) #Adds 10A vacuum in z-dir
        Li.set_pbc(1)
        view(Li)

        exit()
